---
description: Стратегия миграции с сохранением существующей функциональности
alwaysApply: true
---

# Стратегия миграции TamaFi на новое устройство

## Основной принцип

**МАКСИМАЛЬНО СОХРАНЯТЬ оригинальный код. НЕ УДАЛЯТЬ существующую функциональность, а делать её ОПЦИОНАЛЬНОЙ через условную компиляцию и развилки в коде.**

### Ключевые требования:

1. **Оригинальный код остается НЕТРОНУТЫМ** - все функции, переменные, логика должны оставаться как есть
2. **Новая функциональность добавляется РЯДОМ**, а не вместо старой
3. **Развилки создаются в точках инициализации и вызова**, а не в теле оригинальных функций
4. **Правило применяется ко ВСЕЙ функциональности**: дисплей, ввод, светодиоды, звук, WiFi, сохранение и т.д.

## Правила миграции

### 1. Определение типа устройства при инициализации

В начале `setup()` или в отдельном модуле инициализации **ОБЯЗАТЕЛЬНО** определить тип устройства и сохранить в глобальной переменной/константе:

```cpp
// В начале кода (после includes)
#define DEVICE_TYPE_ORIGINAL 0  // ESP32-S3 с TFT ST7789 240x240
#define DEVICE_TYPE_WAVESHARE 1 // ESP32-S3-Touch-AMOLED-1.8

// Определение типа устройства (можно через #define или runtime detection)
#ifndef TARGET_DEVICE
  #define TARGET_DEVICE DEVICE_TYPE_ORIGINAL  // По умолчанию оригинальное устройство
#endif

// Или runtime определение:
int deviceType = detectDeviceType(); // Функция определяет устройство по пинам/характеристикам
```

### 2. Развилка для драйверов дисплея

**ПРИМЕР ПРАВИЛЬНОГО ПОДХОДА:**

```cpp
// В setup() или initDisplay()
void initDisplay() {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    // Оригинальный код для TFT_eSPI
    tft.init();
    tft.setRotation(0);
    tft.setSwapBytes(true);
    
    fb.setColorDepth(16);
    fb.createSprite(TFT_W, TFT_H);
    // ... остальная инициализация оригинального дисплея
  } 
  else if (deviceType == DEVICE_TYPE_WAVESHARE) {
    // Новый код для GFX_Library_for_Arduino
    Arduino_DataBus *bus = new Arduino_ESP32QSPI(...);
    gfx = new Arduino_SH8601(bus, -1, 0, false, LCD_WIDTH, LCD_HEIGHT);
    gfx->begin();
    // ... инициализация нового дисплея
  }
}
```

**НЕПРАВИЛЬНО:**
- ❌ Удалять код оригинального дисплея
- ❌ Заменять напрямую без проверки типа устройства
- ❌ Использовать только новый код без поддержки старого

### 3. Абстракция для графических операций

Создать функции-обертки, которые работают с обоими типами дисплеев:

```cpp
// В display_wrapper.h или аналогичном файле
void displayFillScreen(uint16_t color) {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    tft.fillScreen(color);
  } else {
    gfx->fillScreen(color);
  }
}

void displayDrawPixel(int x, int y, uint16_t color) {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    tft.drawPixel(x, y, color);
  } else {
    gfx->drawPixel(x, y, color);
  }
}

// И так далее для всех графических операций
```

### 4. Сохранение логики проекта

**ВСЯ ЛОГИКА ПРОЕКТА ДОЛЖНА ОСТАТЬСЯ БЕЗ ИЗМЕНЕНИЙ:**

- ✅ `logicTick()` - **БЕЗ ИЗМЕНЕНИЙ, оригинальный код**
- ✅ `resolveHunt()`, `resolveDiscover()` - **БЕЗ ИЗМЕНЕНИЙ, оригинальный код**
- ✅ WiFi сканирование - **БЕЗ ИЗМЕНЕНИЙ, оригинальный код**
- ✅ Сохранение состояния - **БЕЗ ИЗМЕНЕНИЙ, оригинальный код**
- ✅ Логика питомца (hunger, happiness, health) - **БЕЗ ИЗМЕНЕНИЙ, оригинальный код**
- ✅ Эволюция, настроения - **БЕЗ ИЗМЕНЕНИЙ, оригинальный код**
- ✅ Все таймеры, счетчики, состояния - **БЕЗ ИЗМЕНЕНИЙ, оригинальный код**

**Меняется ТОЛЬКО через обертки/адаптеры:**
- Инициализация дисплея (через `initDisplay()` с развилкой)
- Функции отрисовки (через обертки `displayFillScreen()` и т.д.)
- Обработка ввода (через обертки `isButtonPressed()`)
- Светодиоды (через обертки `ledsHappy()` → `setMoodIndicator()`)
- Звук (через обертки, если нужно)

### 5. Развилка для ввода

```cpp
// В input.h / input.cpp
bool isButtonPressed(int buttonId) {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    // Оригинальный код для физических кнопок
    return digitalRead(buttonPins[buttonId]) == LOW;
  } else {
    // Новый код для тач-экрана + физических кнопок
    return getTouchInput(buttonId) || getPhysicalButton(buttonId);
  }
}
```

### 6. Константы разрешения экрана

```cpp
// В начале кода или в config.h
#if TARGET_DEVICE == DEVICE_TYPE_ORIGINAL
  #define DISPLAY_W 240
  #define DISPLAY_H 240
  #define CONTENT_W 240
  #define CONTENT_H 240
#elif TARGET_DEVICE == DEVICE_TYPE_WAVESHARE
  #define DISPLAY_W 368
  #define DISPLAY_H 448
  #define CONTENT_W 368
  #define CONTENT_H 368  // Основная область
  #define CONTROL_H 80   // Область управления
#endif
```

### 7. Масштабирование контента

Для нового устройства использовать масштабирование, но сохранить оригинальные размеры спрайтов:

```cpp
void drawScaledContent() {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    // Оригинальная отрисовка без масштабирования - КОД НЕ МЕНЯЕТСЯ
    fb.pushSprite(0, 0);
  } else {
    // Масштабирование 240x240 → 368x368
    scaleAndDraw(fb, 0, 0, CONTENT_W, CONTENT_H, SCALE_FACTOR);
    // Отрисовка области управления
    drawControlArea(0, CONTENT_H, DISPLAY_W, CONTROL_H);
  }
}
```

### 8. Светодиоды → Экранные индикаторы

**ПРАВИЛЬНО - сохранить оригинальные функции, добавить обертки:**

```cpp
// ОРИГИНАЛЬНЫЙ КОД ОСТАЕТСЯ БЕЗ ИЗМЕНЕНИЙ
void ledsHappy() {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    // Оригинальный код для NeoPixels - НЕ ТРОГАТЬ
    for (int i = 0; i < LED_COUNT; i++) {
      leds.setPixelColor(i, leds.Color(0, 150, 255));
    }
    leds.show();
  } else {
    // Новая функциональность - экранные индикаторы
    drawMoodIndicator(MOOD_HAPPY);
  }
}

// Аналогично для всех функций: ledsSad(), ledsWifi(), ledsRest(), ledsOff()
```

**НЕПРАВИЛЬНО:**
- ❌ Удалять функции `ledsHappy()`, `ledsSad()` и т.д.
- ❌ Заменять их содержимое полностью
- ❌ Изменять вызовы этих функций в оригинальном коде

### 9. Звук

**ПРАВИЛЬНО - сохранить оригинальный код:**

```cpp
// ОРИГИНАЛЬНЫЙ КОД ОСТАЕТСЯ БЕЗ ИЗМЕНЕНИЙ
void sndHatch() {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    // Оригинальный код для PWM buzzer - НЕ ТРОГАТЬ
    ledcWriteTone(BUZZER_CH, 800);
    delay(100);
    ledcWriteTone(BUZZER_CH, 0);
  } else {
    // Можно использовать ES8311 или тот же PWM
    // Но оригинальный код остается
    ledcWriteTone(BUZZER_CH, 800);
    delay(100);
    ledcWriteTone(BUZZER_CH, 0);
  }
}
```

### 10. WiFi и сохранение состояния

**ЭТИ КОМПОНЕНТЫ НЕ МЕНЯЮТСЯ ВООБЩЕ:**

```cpp
// Оригинальный код остается полностью без изменений
void startWifiScan() {
  // ОРИГИНАЛЬНЫЙ КОД - НЕ ТРОГАТЬ
  if (wifiScanInProgress) return;
  wifiScanInProgress = true;
  WiFi.scanNetworks(true, true);
  // ... остальной оригинальный код
}

void saveState() {
  // ОРИГИНАЛЬНЫЙ КОД - НЕ ТРОГАТЬ
  prefs.putInt("hunger", pet.hunger);
  // ... остальной оригинальный код
}
```

### 11. Инициализация оборудования

**ПРАВИЛЬНО - развилка только в setup(), оригинальные функции не меняются:**

```cpp
void setup() {
  // Определить тип устройства
  initDeviceType();
  
  // Развилка для инициализации
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    // Вызов оригинальных функций инициализации - КОД НЕ МЕНЯЕТСЯ
    initOriginalHardware();  // Внутри - оригинальный код без изменений
  } else {
    // Новая инициализация для нового устройства
    initNewHardware();
  }
  
  // Общая инициализация (одинаковая для обоих) - оригинальный код
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true);
  prefs.begin("tamafi2", false);
  loadState();
  // ... остальной оригинальный код
}
```

## Структура файлов при миграции

### Рекомендуемая структура:

```
TamaFi/
├── TamaFi.ino              # Основной файл (логика без изменений)
├── ui.cpp                  # UI (адаптирован через обертки)
├── ui.h
├── display_wrapper.h       # НОВЫЙ: Абстракция для дисплея
├── display_wrapper.cpp     # НОВЫЙ: Реализация оберток
├── input_wrapper.h         # НОВЫЙ: Абстракция для ввода
├── input_wrapper.cpp       # НОВЫЙ: Реализация ввода
├── device_config.h          # НОВЫЙ: Определение типа устройства
└── ...
```

## Чеклист при миграции

Перед каждым изменением проверь:

- [ ] **Оригинальный код остался полностью нетронутым?**
- [ ] **Все оригинальные функции сохранены без изменений?**
- [ ] **Развилка создана только в точках инициализации/вызова?**
- [ ] **Есть ли развилка `if (deviceType == ...)` для новой функциональности?**
- [ ] **Работает ли код на оригинальном устройстве без изменений?**
- [ ] **Работает ли код на новом устройстве?**
- [ ] **Не удален ли ни один оригинальный файл/функция/переменная?**
- [ ] **Логика проекта (`logicTick`, `resolveHunt`, и т.д.) не изменена?**
- [ ] **WiFi, сохранение, таймеры - без изменений?**
- [ ] **Все вызовы оригинальных функций остались как есть?**

## Примеры правильных изменений

### ✅ ПРАВИЛЬНО - Максимальное сохранение оригинального кода:

```cpp
// setup() - добавляем развилку, но оригинальные функции не меняем
void setup() {
  initDeviceType();  // Определить тип устройства
  
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    // Вызываем оригинальные функции - КОД ВНУТРИ НЕ МЕНЯЕТСЯ
    tft.init();  // Оригинальная функция остается как есть
    tft.setRotation(0);
    // ... весь оригинальный код инициализации
  } else {
    // Новая инициализация для нового устройства
    gfx->begin();
    // ...
  }
  
  // Оригинальный код остается полностью без изменений
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true);
  prefs.begin("tamafi2", false);
  loadState();
  // ... весь остальной оригинальный код
}

// Оригинальные функции остаются полностью нетронутыми
void logicTick() {
  // ВСЯ ЛОГИКА ОСТАЕТСЯ БЕЗ ИЗМЕНЕНИЙ
  // Никаких if (deviceType == ...) внутри!
  unsigned long now = millis();
  // ... весь оригинальный код
}

void resolveHunt() {
  // ВСЯ ЛОГИКА ОСТАЕТСЯ БЕЗ ИЗМЕНЕНИЙ
  // Никаких if (deviceType == ...) внутри!
  // ... весь оригинальный код
}
```

### ❌ НЕПРАВИЛЬНО - Изменение оригинального кода:

```cpp
// ❌ Удаление оригинального кода
void setup() {
  // Старый код удален!
  gfx->begin();  // Только новый код
  initTouchScreen();  // Только новый код
}

// ❌ Изменение оригинальных функций
void logicTick() {
  if (deviceType == DEVICE_TYPE_WAVESHARE) {
    // Новая логика
  } else {
    // Оригинальная логика
  }
  // НЕПРАВИЛЬНО! Оригинальная функция изменена
}

// ❌ Удаление оригинальных функций
// void ledsHappy() { ... }  // УДАЛЕНО - НЕПРАВИЛЬНО!
```

### ✅ ПРАВИЛЬНО - Обертки для всех компонентов:

```cpp
// display_wrapper.cpp - обертки для дисплея
void displayFillScreen(uint16_t color) {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    tft.fillScreen(color);  // Оригинальный вызов
  } else {
    gfx->fillScreen(color);  // Новый вызов
  }
}

// input_wrapper.cpp - обертки для ввода
bool isButtonPressed(int buttonId) {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    return digitalRead(buttonPins[buttonId]) == LOW;  // Оригинальный код
  } else {
    return getTouchInput(buttonId);  // Новый код
  }
}

// leds_wrapper.cpp - обертки для светодиодов
void setMoodIndicator(Mood mood) {
  if (deviceType == DEVICE_TYPE_ORIGINAL) {
    ledsHappy();  // Вызов оригинальной функции - КОД НЕ МЕНЯЕТСЯ
  } else {
    drawMoodIndicatorOnScreen(mood);  // Новая функциональность
  }
}
```

## Итоговый принцип

**"МАКСИМАЛЬНО СОХРАНЯЙ оригинальный код. Добавляй, не заменяй. Развивай, не удаляй."**

### Правило применяется ко ВСЕЙ функциональности:

- ✅ **Дисплей** - оригинальный код TFT_eSPI остается, добавляется поддержка GFX_Library_for_Arduino
- ✅ **Ввод** - оригинальный код кнопок остается, добавляется поддержка тач-экрана
- ✅ **Светодиоды** - оригинальные функции `ledsHappy()`, `ledsSad()` остаются, добавляются экранные индикаторы
- ✅ **Звук** - оригинальный код PWM остается, можно добавить ES8311
- ✅ **WiFi** - оригинальный код остается полностью без изменений
- ✅ **Сохранение** - оригинальный код Preferences остается полностью без изменений
- ✅ **Логика** - весь код `logicTick()`, `resolveHunt()`, `resolveDiscover()` остается без изменений
- ✅ **Таймеры** - все таймеры и счетчики остаются без изменений
- ✅ **Состояния** - все переменные состояния остаются без изменений

### Что можно менять:

- ✅ Добавлять новые файлы (обертки, адаптеры)
- ✅ Добавлять развилки в `setup()` и точках инициализации
- ✅ Создавать функции-обертки для абстракции
- ✅ Добавлять условную компиляцию через `#ifdef`

### Что НЕЛЬЗЯ менять:

- ❌ Удалять оригинальные функции
- ❌ Изменять тело оригинальных функций
- ❌ Удалять оригинальные переменные
- ❌ Изменять логику проекта
- ❌ Удалять оригинальные файлы
- ❌ Изменять вызовы оригинальных функций в оригинальном коде

---

## Роль AI ассистента в процессе миграции

### Основные принципы работы AI ассистента:

1. **Всегда спрашивать перед изменениями**
   - ❌ НЕ вносить изменения без явного подтверждения пользователя
   - ✅ Предлагать изменения и ждать подтверждения
   - ✅ Даже для мелких правок - сначала предложить, потом выполнить
   - ✅ При явном запросе пользователя ("исправь ошибку", "создай файл") - уточнить детали перед действием

2. **Полная ответственность за качество**
   - ✅ Отвечать за корректность миграции
   - ✅ Отвечать за работоспособность кода
   - ✅ Отвечать за соответствие правилам миграции
   - ✅ При ошибках - предлагать варианты: откатывать или исправлять, решать по месту

3. **Мелкие правки**
   - ✅ Можно вносить без ограничений (после подтверждения):
     - Форматирование кода
     - Добавление/исправление комментариев
     - Переименование переменных (с сохранением логики)
     - Исправление опечаток
     - Улучшение читаемости кода
   - ✅ Всегда спрашивать перед внесением, даже для мелких правок

4. **Приоритет: сохранение оригинального кода**
   - ✅ Важнее сохранить оригинальный код, чем скорость миграции
   - ✅ При конфликте между правилами - приоритет у сохранения оригинального кода
   - ✅ Всегда проверять, не нарушает ли изменение оригинальную функциональность

5. **Предложение улучшений**
   - ✅ Всегда предлагать улучшения помимо миграции:
     - Оптимизация кода
     - Улучшение архитектуры
     - Рефакторинг (с сохранением логики)
     - Улучшение производительности
   - ✅ Предлагать, но не внедрять без подтверждения

6. **История изменений**
   - ✅ Фиксировать изменения только по запросу пользователя
   - ✅ По запросу создавать коммиты с описанием изменений
   - ✅ Отслеживать, что было изменено и почему (для будущих коммитов)

7. **Обработка багов и ошибок**
   - ✅ При обнаружении бага в оригинальном коде - сообщать пользователю
   - ✅ Предлагать варианты исправления
   - ✅ Решать по месту: исправлять или оставить как есть
   - ✅ При ошибках миграции - предлагать: откатывать или исправлять

### Процесс работы AI ассистента:

#### Шаг 1: Анализ задачи
- Изучить контекст и требования
- Проверить соответствие правилам миграции
- Определить, что нужно изменить

#### Шаг 2: Предложение решения
- Описать планируемые изменения
- Показать примеры кода (если нужно)
- Объяснить, почему это решение соответствует правилам
- Предложить альтернативы (если есть)

#### Шаг 3: Ожидание подтверждения
- Дождаться явного подтверждения пользователя
- Уточнить детали, если что-то неясно
- НЕ вносить изменения до подтверждения

#### Шаг 4: Выполнение
- Внести изменения согласно правилам миграции
- Сохранить оригинальный код
- Добавить развилки/обертки где нужно
- Проверить соответствие правилам

#### Шаг 5: Отчет
- Сообщить о выполненных изменениях
- Указать, что было сохранено из оригинального кода
- Предложить следующие шаги (если нужно)

### Примеры взаимодействия:

#### ✅ ПРАВИЛЬНО:

```
Пользователь: "Создай обертку для дисплея"

AI: "Я предлагаю создать файл display_wrapper.h и display_wrapper.cpp 
с функциями-обертками для обоих типов дисплеев. Это сохранит оригинальный 
код TFT_eSPI и добавит поддержку GFX_Library_for_Arduino. 

Планируемые функции:
- displayFillScreen()
- displayDrawPixel()
- displayInit()

Создать эти файлы?"

[Ждет подтверждения]
```

#### ❌ НЕПРАВИЛЬНО:

```
Пользователь: "Создай обертку для дисплея"

AI: [Сразу создает файлы без объяснения и подтверждения]
```

### Чеклист для AI ассистента перед любым изменением:

- [ ] Понял ли я задачу правильно?
- [ ] Соответствует ли решение правилам миграции?
- [ ] Сохраняется ли оригинальный код?
- [ ] Предложил ли я решение пользователю?
- [ ] Получил ли я подтверждение?
- [ ] Нет ли конфликтов с другими правилами?

---

*Это правило гарантирует, что проект будет работать на обоих устройствах одновременно, позволяя постепенно мигрировать без потери функциональности и с максимальным сохранением оригинального кода.*
